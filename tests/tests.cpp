#include <iostream>
#include <vector>

#include "aes.h"
#include "gtest/gtest.h"

const unsigned int BLOCK_BYTES_LENGTH = 16 * sizeof(unsigned char);

TEST(KeyLengths, KeyLength128) {
    AES<AESKeyLength::AES_128> aes;
    unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
    unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                           0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
    unsigned char right[] = {0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd,
                             0x77, 0x28, 0x55, 0xfc, 0x87, 0xca, 0x96, 0x4d};

    auto out = aes.encrypt_cbc(plain, BLOCK_BYTES_LENGTH, key, iv);
    ASSERT_FALSE(memcmp(right, out.get(), BLOCK_BYTES_LENGTH));
}

TEST(KeyLengths, KeyLength192) {
    AES<AESKeyLength::AES_192> aes;
    unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
    unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
                           0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17};
    unsigned char right[] = {0x32, 0x22, 0xd9, 0x30, 0x98, 0x0a, 0xa5, 0x25,
                             0x79, 0x8f, 0x53, 0x79, 0xe7, 0xf9, 0x00, 0x90};

    auto out = aes.encrypt_cbc(plain, BLOCK_BYTES_LENGTH, key, iv);
    ASSERT_FALSE(memcmp(right, out.get(), BLOCK_BYTES_LENGTH));
}

TEST(KeyLengths, KeyLength256) {
    AES<AESKeyLength::AES_256> aes;
    unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
    unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
                           0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
                           0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
    unsigned char right[] = {0x4c, 0x5e, 0x3c, 0x10, 0xdd, 0x6a, 0x2f, 0x21,
                             0x34, 0x6b, 0xc3, 0x1c, 0x59, 0x0f, 0x6f, 0xf9};

    auto out = aes.encrypt_cbc(plain, BLOCK_BYTES_LENGTH, key, iv);
    ASSERT_FALSE(memcmp(right, out.get(), BLOCK_BYTES_LENGTH));
}

TEST(CBC, EncryptDecrypt) {
    AES<AESKeyLength::AES_256> aes;
    unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                             0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
    unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
                           0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
                           0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

    auto out = aes.encrypt_cbc(plain, BLOCK_BYTES_LENGTH, key, iv);
    auto innew = aes.decrypt_cbc(out.get(), BLOCK_BYTES_LENGTH, key, iv);
    ASSERT_FALSE(memcmp(innew.get(), plain, BLOCK_BYTES_LENGTH));
}

TEST(CBC, LongPlainEncryptDecrypt) {
    AES<AESKeyLength::AES_256> aes;
    auto get_random_plain = [](size_t length) {
        auto plain = std::make_unique<uint8_t[]>(length);
        for (size_t i = 0; i < length; i++) {
            plain.get()[i] = rand() % 256;
        }
        return plain;
    };
    auto plain = get_random_plain(BLOCK_BYTES_LENGTH * 1024 * 1024);
    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
                           0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
                           0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};

    auto out = aes.encrypt_cbc(plain.get(), BLOCK_BYTES_LENGTH * 1024 * 1024, key);
    auto innew = aes.decrypt_cbc(out.get(), BLOCK_BYTES_LENGTH * 1024 * 1024, key);
    ASSERT_FALSE(memcmp(innew.get(), plain.get(), BLOCK_BYTES_LENGTH * 1024 * 1024));
}

TEST(CBC, TwoBlocksEncrypt) {
    AES<AESKeyLength::AES_128> aes;
    unsigned char plain[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
                             0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                             0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
    unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                           0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
    unsigned char right[] = {0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd, 0x77, 0x28, 0x55,
                             0xfc, 0x87, 0xca, 0x96, 0x4d, 0x4c, 0x5b, 0xca, 0x1c, 0x48, 0xcd,
                             0x88, 0x00, 0x3a, 0x10, 0x52, 0x11, 0x88, 0x12, 0x5e, 0x00};

    auto out = aes.encrypt_cbc(plain, 2 * BLOCK_BYTES_LENGTH, key, iv);
    ASSERT_FALSE(memcmp(out.get(), right, 2 * BLOCK_BYTES_LENGTH));
}

TEST(CBC, TwoBlocksDecrypt) {
    AES<AESKeyLength::AES_128> aes;
    unsigned char encrypted[] = {0x1b, 0x87, 0x23, 0x78, 0x79, 0x5f, 0x4f, 0xfd, 0x77, 0x28, 0x55,
                                 0xfc, 0x87, 0xca, 0x96, 0x4d, 0x4c, 0x5b, 0xca, 0x1c, 0x48, 0xcd,
                                 0x88, 0x00, 0x3a, 0x10, 0x52, 0x11, 0x88, 0x12, 0x5e, 0x00};

    unsigned char iv[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                           0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};
    unsigned char right[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa,
                             0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
                             0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};

    auto out = aes.decrypt_cbc(encrypted, 2 * BLOCK_BYTES_LENGTH, key, iv);
    ASSERT_FALSE(memcmp(out.get(), right, 2 * BLOCK_BYTES_LENGTH));
}

int
main(int argc, char* argv[]) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
